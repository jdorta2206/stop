rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Users Collection: Public profiles are readable, but users can only write to their own document.
    match /users/{userId} {
      allow read;
      allow write: if request.auth != null && request.auth.uid == userId;

      // Friends Subcollection: Only the user can manage their own friends list.
      match /friends/{friendId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Notifications Subcollection: Authenticated users can send notifications (create), but only the recipient can read or update them.
      match /notifications/{notificationId} {
        allow create: if request.auth != null;
        allow read, update, delete: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Rooms Collection: Authenticated users can create and read rooms. Updates are restricted.
    match /rooms/{roomId} {
      allow read, create: if request.auth != null;
      // Allow updates if the user is authenticated (simplification for now).
      // A more robust rule would check if the user is part of the room.
      allow update, delete: if request.auth != null;
      
      // Chat Subcollection within a room
      match /chat/{messageId} {
        allow read, create: if request.auth != null && exists(/databases/$(database)/documents/rooms/$(roomId)/players/$(request.auth.uid));
      }
    }

    // Rankings Collection: Publicly readable, but writes are handled by backend/trusted logic.
    // For this app, we allow players to update their own ranking document.
    match /rankings/{playerId} {
      allow read;
      allow write: if request.auth != null && request.auth.uid == playerId;

      // Game History Subcollection
      match /gameHistory/{gameId} {
        allow read, create: if request.auth != null && request.auth.uid == playerId;
      }
    }
  }
}
